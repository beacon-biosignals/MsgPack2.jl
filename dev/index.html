<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Documentation · MsgPack2</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MsgPack2</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>API Documentation</a><ul class="internal"><li><a class="toctext" href="#Basic-Serialization/Deserialization-1">Basic Serialization/Deserialization</a></li><li><a class="toctext" href="#Julia-–-MessagePack-Conversion-1">Julia &lt;–&gt; MessagePack Conversion</a></li><li><a class="toctext" href="#Julia-–-MessagePack-Interface-Types-1">Julia &lt;–&gt; MessagePack Interface Types</a></li><li><a class="toctext" href="#View-Types-1">View Types</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API Documentation</a></li></ul><a class="edit-page" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API Documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Documentation-1" href="#API-Documentation-1">API Documentation</a></h1><p>Below is the documentation for all MsgPack2 API functions. For information on MsgPack2, please see <a href="https://github.com/beacon-biosignals/MsgPack2.jl">the package&#39;s README</a>.</p><h2><a class="nav-anchor" id="Basic-Serialization/Deserialization-1" href="#Basic-Serialization/Deserialization-1">Basic Serialization/Deserialization</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack2.unpack" href="#MsgPack2.unpack"><code>MsgPack2.unpack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">unpack(bytes, T::Type = Any)</code></pre><p>Return <code>unpack(IOBuffer(bytes), T)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/unpack.jl#L4-L8">source</a><div><div><pre><code class="language-none">unpack(msgpack_byte_stream::IO, T::Type = Any)</code></pre><p>Return the Julia value of type <code>T</code> deserialized from <code>msgpack_byte_stream</code>.</p><p><code>T</code> is assumed to have valid <a href="#MsgPack2.msgpack_type"><code>msgpack_type</code></a> and <a href="#MsgPack2.from_msgpack"><code>from_msgpack</code></a> definitions.</p><p>If <code>msgpack_type(T) === AnyType()</code>, <code>unpack</code> will deserialize the next MessagePack object from <code>msgpack_byte_stream</code> into the default Julia representation corresponding to the object&#39;s MessagePack type. For details on default Julia representations, see <a href="#MsgPack2.AbstractMsgPackType"><code>AbstractMsgPackType</code></a>.</p><p>See also: <a href="#MsgPack2.pack"><code>pack</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/unpack.jl#L11-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack2.pack" href="#MsgPack2.pack"><code>MsgPack2.pack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pack(x)</code></pre><p>Serialize <code>x</code> to MessagePack format and return the resulting <code>Vector{UInt8}</code>.</p><p>This function uses <a href="#MsgPack2.msgpack_type"><code>msgpack_type</code></a> and <a href="#MsgPack2.to_msgpack"><code>to_msgpack</code></a> to determine the appropriate translation of the <code>value</code> into MessagePack format.</p><p>See also: <a href="#MsgPack2.unpack"><code>unpack</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/pack.jl#L2-L11">source</a><div><div><pre><code class="language-none">pack(io::IO, x)</code></pre><p>Like <code>pack(x)</code>, but write the resulting bytes to <code>io</code>.</p><p>See also: <a href="#MsgPack2.unpack"><code>unpack</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/pack.jl#L19-L25">source</a></section><h2><a class="nav-anchor" id="Julia-–-MessagePack-Conversion-1" href="#Julia-–-MessagePack-Conversion-1">Julia &lt;–&gt; MessagePack Conversion</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack2.msgpack_type" href="#MsgPack2.msgpack_type"><code>MsgPack2.msgpack_type</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">msgpack_type(::Type{T}) where {T}</code></pre><p>Return an instance of the <a href="#MsgPack2.AbstractMsgPackType"><code>AbstractMsgPackType</code></a> subtype corresponding to <code>T</code>&#39;s intended MessagePack representation. For example:</p><pre><code class="language-none">msgpack_type(::Type{UUID}) = StringType()</code></pre><p>If this method is overloaded such that <code>msgpack_type(T) === M()</code>, then <code>to_msgpack(::M, ::T)</code> and <code>from_msgpack(::Type{T}, x)</code> should also be overloaded to handle conversion of <code>T</code> instances to/from MsgPack2-compatible types.</p><p>By default, this method returns <code>AnyType()</code>. While this fallback method need not be overloaded to support deserialization of <code>T</code> instances via <code>unpack</code>, <code>msgpack_type(T)</code> must be overloaded to return a non-<code>AnyType</code> <code>AbstractMsgPackType</code> instance in order to support serializing <code>T</code> instances via <code>pack</code>.</p><p>See also: <a href="#MsgPack2.from_msgpack"><code>from_msgpack</code></a>, <a href="#MsgPack2.to_msgpack"><code>to_msgpack</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/types.jl#L195-L215">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack2.to_msgpack" href="#MsgPack2.to_msgpack"><code>MsgPack2.to_msgpack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">to_msgpack(::M, value_to_serialize::T) where {M&lt;:AbstractMsgPackType,T}</code></pre><p>Return an &quot;<code>M</code>-compatible&quot; representation of <code>value_to_serialize</code> (for compatibility definitions, see the docstrings for subtypes of `AbstractMsgPackType).</p><p>By default, <code>to_msgpack</code> simply returns <code>value_to_serialize</code> directly.</p><p>The implementation of <a href="#MsgPack2.pack"><code>pack</code></a> utilizes this function for every value encountered during serialization, calling it in a manner similar to the following psuedocode:</p><pre><code class="language-none">t = msgpack_type(T)
value_in_compatible_representation = to_msgpack(t, value_to_serialize::T)
_serialize_in_msgpack_format(t, value_in_compatible_representation)</code></pre><p>For example, if <code>msgpack_type(UUID)</code> was defined to return <code>StringType()</code>, an appropriate <code>to_msgpack</code> implementation might be:</p><pre><code class="language-none">to_msgpack(::StringType, uuid::UUID) = string(uuid)</code></pre><p>See also: <a href="#MsgPack2.from_msgpack"><code>from_msgpack</code></a>, <a href="#MsgPack2.msgpack_type"><code>msgpack_type</code></a>, <a href="#MsgPack2.AbstractMsgPackType"><code>AbstractMsgPackType</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/types.jl#L218-L244">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack2.from_msgpack" href="#MsgPack2.from_msgpack"><code>MsgPack2.from_msgpack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">from_msgpack(::Type{T}, value_deserialized_by_msgpack) where {T}</code></pre><p>Return the <code>value_deserialized_by_msgpack</code> converted to type <code>T</code>. By default, this method simply calls <code>convert(T, value_deserialized_by_msgpack)</code>.</p><p>The implementation of <a href="#MsgPack2.unpack"><code>unpack</code></a> calls this function on every deserialized value; in this case, <code>T</code> is generally derived from the type specified by the caller of <code>unpack</code>.</p><p>For example, if <code>msgpack_type(UUID)</code> was defined to return <code>StringType()</code>, an appropriate <code>from_msgpack</code> implementation might be:</p><pre><code class="language-none">from_msgpack(::Type{UUID}, uuid::AbstractString) = UUID(uuid)</code></pre><p>See also: <a href="#MsgPack2.to_msgpack"><code>to_msgpack</code></a>, <a href="#MsgPack2.msgpack_type"><code>msgpack_type</code></a>, <a href="#MsgPack2.AbstractMsgPackType"><code>AbstractMsgPackType</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/types.jl#L247-L265">source</a></section><h2><a class="nav-anchor" id="Julia-–-MessagePack-Interface-Types-1" href="#Julia-–-MessagePack-Interface-Types-1">Julia &lt;–&gt; MessagePack Interface Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack2.AbstractMsgPackType" href="#MsgPack2.AbstractMsgPackType"><code>MsgPack2.AbstractMsgPackType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractMsgPackType</code></pre><p>An abstract type whose subtypes define a MessagePack &lt;–&gt; Julia type interface.</p><p>The subtypes of <code>AbstractMsgPackType</code> are:</p><ul><li><a href="#MsgPack2.IntegerType"><code>IntegerType</code></a></li><li><a href="#MsgPack2.NilType"><code>NilType</code></a></li><li><a href="#MsgPack2.BooleanType"><code>BooleanType</code></a></li><li><a href="#MsgPack2.FloatType"><code>FloatType</code></a></li><li><a href="#MsgPack2.StringType"><code>StringType</code></a></li><li><a href="#MsgPack2.BinaryType"><code>BinaryType</code></a></li><li><a href="#MsgPack2.ArrayType"><code>ArrayType</code></a></li><li><a href="#MsgPack2.MapType"><code>MapType</code></a></li><li><a href="#MsgPack2.AnyType"><code>AnyType</code></a></li><li><a href="#MsgPack2.ImmutableStructType"><code>ImmutableStructType</code></a></li><li><a href="#MsgPack2.MutableStructType"><code>MutableStructType</code></a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/types.jl#L5-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack2.IntegerType" href="#MsgPack2.IntegerType"><code>MsgPack2.IntegerType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IntegerType &lt;: AbstractMsgPackType</code></pre><p>A Julia type corresponding to the MessagePack Integer type.</p><p>If <code>msgpack_type(T)</code> is defined to return <code>IntegerType()</code>, then <code>T</code> must support:</p><ul><li><code>to_msgpack(::IntegerType, ::T)::S</code></li><li><code>from_msgpack(::Type{T}, ::S)::T</code></li><li>standard numeric comparators (<code>&gt;</code>, <code>&lt;</code>, <code>==</code>, etc.) against values of type <code>S</code></li></ul><p>where <code>S</code> may be one of the following types:</p><ul><li><code>UInt8</code></li><li><code>UInt16</code></li><li><code>UInt32</code></li><li><code>UInt64</code></li><li><code>Int8</code></li><li><code>Int16</code></li><li><code>Int32</code></li><li><code>Int64</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/types.jl#L26-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack2.NilType" href="#MsgPack2.NilType"><code>MsgPack2.NilType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NilType &lt;: AbstractMsgPackType</code></pre><p>A Julia type corresponding to the MessagePack Nil type.</p><p>If <code>msgpack_type(T)</code> is defined to return <code>NilType()</code>, then <code>T</code> must support:</p><ul><li><code>from_msgpack(::Type{T}, ::Nothing)::T</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/types.jl#L50-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack2.BooleanType" href="#MsgPack2.BooleanType"><code>MsgPack2.BooleanType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BooleanType &lt;: AbstractMsgPackType</code></pre><p>A Julia type corresponding to the MessagePack Boolean type.</p><p>If <code>msgpack_type(T)</code> is defined to return <code>BooleanType()</code>, then <code>T</code> must support:</p><ul><li><code>to_msgpack(::BooleanType, ::T)::Bool</code></li><li><code>from_msgpack(::Type{T}, ::Bool)::T</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/types.jl#L61-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack2.FloatType" href="#MsgPack2.FloatType"><code>MsgPack2.FloatType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FloatType &lt;: AbstractMsgPackType</code></pre><p>A Julia type corresponding to the MessagePack Float type.</p><p>If <code>msgpack_type(T)</code> is defined to return <code>FloatType()</code>, then <code>T</code> must support:</p><ul><li><code>to_msgpack(::FloatType, ::T)::S</code></li><li><code>from_msgpack(::Type{T}, ::S)::T</code></li><li>standard numeric comparators (<code>&gt;</code>, <code>&lt;</code>, <code>==</code>, etc.) against values of type <code>S</code></li></ul><p>where <code>S</code> may be one of the following types:</p><ul><li><code>Float32</code></li><li><code>Float64</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/types.jl#L73-L88">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack2.StringType" href="#MsgPack2.StringType"><code>MsgPack2.StringType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StringType &lt;: AbstractMsgPackType</code></pre><p>A Julia type corresponding to the MessagePack String type.</p><p>If <code>msgpack_type(T)</code> is defined to return <code>StringType()</code>, then <code>T</code> must support:</p><ul><li><code>to_msgpack(::StringType, ::T)::String</code></li><li><code>from_msgpack(::Type{T}, ::String)::T</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/types.jl#L91-L100">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack2.BinaryType" href="#MsgPack2.BinaryType"><code>MsgPack2.BinaryType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BinaryType &lt;: AbstractMsgPackType</code></pre><p>A Julia type corresponding to the MessagePack Binary type.</p><p>If <code>msgpack_type(T)</code> is defined to return <code>BinaryType()</code>, then <code>T</code> must support:</p><ul><li><code>to_msgpack(::BinaryType, ::T)::Vector{UInt8}</code></li><li><code>from_msgpack(::Type{T}, ::Vector{UInt8})::T</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/types.jl#L103-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack2.ArrayType" href="#MsgPack2.ArrayType"><code>MsgPack2.ArrayType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ArrayType &lt;: AbstractMsgPackType</code></pre><p>A Julia type corresponding to the MessagePack Array type.</p><p>If <code>msgpack_type(T)</code> is defined to return <code>ArrayType()</code>, then <code>T</code> must support the Julia <code>AbstractArray</code> interface, and/or must support:</p><ul><li><code>to_msgpack(::ArrayType, ::T)::AbstractArray</code></li><li><code>from_msgpack(::Type{T}, ::Vector)::T</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/types.jl#L115-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack2.MapType" href="#MsgPack2.MapType"><code>MsgPack2.MapType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MapType &lt;: AbstractMsgPackType</code></pre><p>A Julia type corresponding to the MessagePack Map type.</p><p>If <code>msgpack_type(T)</code> is defined to return <code>MapType()</code>, then <code>T</code> must support the Julia <code>AbstractDict</code> interface, and/or must support:</p><ul><li><code>to_msgpack(::ArrayType, ::T)::AbstractDict</code></li><li><code>from_msgpack(::Type{T}, ::Dict)::T</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/types.jl#L128-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack2.AnyType" href="#MsgPack2.AnyType"><code>MsgPack2.AnyType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AnyType &lt;: AbstractMsgPackType</code></pre><p>The fallback return type of <code>msgpack_type(::Type)</code>, indicating that the given Julia type does not have a known corresponding MessagePack type.</p></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/types.jl#L141-L146">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack2.ImmutableStructType" href="#MsgPack2.ImmutableStructType"><code>MsgPack2.ImmutableStructType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ImmutableStructType &lt;: AbstractMsgPackType</code></pre><p>If <code>msgpack_type(T)</code> is defined to return <code>ImmutableStructType</code>, <code>T</code> will be (de)serialized as a MessagePack Map type assuming certain constraints that enable additional optimizations:</p><ul><li><code>T</code> supports <code>fieldcount</code>, <code>fieldtype</code>, <code>fieldname</code>, <code>getfield</code>, and a constructor</li></ul><p>that can be called as <code>T((getfield(x::T, i) for i in 1:fieldcount(T))...)</code> for any <code>T</code> instance <code>x</code>.</p><ul><li><a href="#MsgPack2.unpack"><code>unpack</code></a> will assume that incoming bytes to be deserialized to <code>T</code></li></ul><p>will always be formmatted as a MessagePack Map whose fields correspond exactly to the fields of <code>T</code>. In other words, the <code>i</code>th key in the Map must correspond to <code>fieldname(T, i)</code>, and the <code>i</code>th value must correspond to <code>getfield(::T, i)</code>.</p><p>This type is similar to <a href="#MsgPack2.MutableStructType"><code>MutableStructType</code></a>, but generally achieves greater (de)serialization performance by imposing tighter constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/types.jl#L149-L167">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack2.MutableStructType" href="#MsgPack2.MutableStructType"><code>MsgPack2.MutableStructType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MutableStructType &lt;: AbstractMsgPackType</code></pre><p>If <code>msgpack_type(T)</code> is defined to return <code>MutableStructType</code>, <code>T</code> will be (de)serialized as a MessagePack Map type assuming certain constraints that enable additional optimizations:</p><ul><li><code>T</code> supports <code>fieldcount</code>, <code>fieldtype</code>, <code>fieldname</code>, <code>getfield</code>, <code>setfield!</code>,</li></ul><p>and has the inner constructor <code>T() = new()</code>.</p><ul><li><a href="#MsgPack2.unpack"><code>unpack</code></a> will assume that incoming bytes to be deserialized to <code>T</code></li></ul><p>will always be formmatted as a MessagePack Map whose fields are an unordered subset of the fields of <code>T</code>. If a given field is not present in the MessagePack Map, the corresponding field of the returned <code>T</code> instance will be left uninitialized.</p><p>This type is similar to <a href="#MsgPack2.ImmutableStructType"><code>ImmutableStructType</code></a>, but imposes fewer constraints at the cost of (de)serialization performance.</p></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/types.jl#L170-L188">source</a></section><h2><a class="nav-anchor" id="View-Types-1" href="#View-Types-1">View Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack2.ArrayView" href="#MsgPack2.ArrayView"><code>MsgPack2.ArrayView</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ArrayView{T} &lt;: AbstractVector{T}</code></pre><p>A Julia struct that wraps a MessagePack byte buffer to provide an immutable view of the MessagePack Array stored within the wrapped byte buffer.</p><p>This type is intended to be utilized via <a href="#MsgPack2.unpack"><code>unpack</code></a>. For example, a call to <code>arr = unpack(bytes, ArrayView{Dict{String,Int32}})</code> will generally return a value more quickly than <code>arr = unpack(bytes, Vector{Dict{String,Int32}})</code>; the latter will perform full deserialization immediately while the former will only scan over <code>bytes</code> to tag the positions of <code>arr</code>&#39;s elements, deferring the actual deserialization of these elements to the time of their access via <code>arr[index]</code>.</p><p>Note that <code>ArrayView</code> does not implement any form of caching - repeat accesses of the same element will re-deserialize the element upon every access.</p></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/views.jl#L5-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack2.MapView" href="#MsgPack2.MapView"><code>MsgPack2.MapView</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MapView{K,V} &lt;: AbstractDict{K,V}</code></pre><p>Similar to <a href="#MsgPack2.ArrayView"><code>ArrayView</code></a>, but provides an immutable view to a MessagePack Map rather than a MessagePack Array.</p><p>This type is intended to be utilized via <a href="#MsgPack2.unpack"><code>unpack</code></a> in the same manner as <code>ArrayView</code>, and is similarly implements a &quot;delay-deserialization-until-access&quot; mechanism.</p></div></div><a class="source-link" target="_blank" href="https://github.com/beacon-biosignals/MsgPack2.jl/blob/6c021a18e2797d139b5a82ff1925a0cb06789245/src/views.jl#L44-L53">source</a></section><footer><hr/></footer></article></body></html>
